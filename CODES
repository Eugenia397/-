блочная (корзинная) сортировка
def bucket_sort(arr):
    # Определяем максимальное значение для расчёта количества бакетов
    max_value = max(arr)
    
    # Количество бакетов выбирается исходя из длины массива (можно настраивать)
    num_buckets = len(arr)
    
    # Создаем список пустых списков (каждый пустой список является бакетом)
    buckets_list = []
    for i in range(num_buckets):
        buckets_list.append([])
        
    # Распределяем элементы массива по соответствующим бакетам
    for j in arr:
        index_b = int((j / max_value) * (num_buckets - 1))
        buckets_list[index_b].append(j)
    
    # Сортируем каждый бакет (используем встроенную сортировку Python)
    for i in range(len(buckets_list)):
        buckets_list[i].sort()
    
    # Объединяем отсортированные бакеты в итоговый отсортированный массив
    final_output = []
    for x in buckets_list:
        final_output.extend(x)
    
    return final_output


# Пример запуска программы
if __name__ == "__main__":
    input_array = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
    print("Исходный массив:", input_array)
    sorted_array = bucket_sort(input_array)
    print("Отсортированный массив:", sorted_array)

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Исходный массив: [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
Отсортированный массив: [0.1234, 0.3434, 0.565, 0.656, 0.665, 0.897]





блинная сортировка
def flip(arr, k):
    """
    Функция переворачивает первые k+1 элементов массива arr.
    Например, flip([1, 2, 3], 1) превратится в [2, 1, 3].
    """
    start = 0
    end = k
    while start < end:
        # Меняем местами первый и последний элементы текущего сегмента
        arr[start], arr[end] = arr[end], arr[start]
        start += 1
        end -= 1

def find_max(arr, n):
    """
    Ищет индекс максимального элемента в первых n элементах массива.
    Возвращает индекс самого большого элемента среди первых n элементов.
    """
    mi = 0
    for i in range(1, n):  # Проверяем остальные элементы начиная со второго
        if arr[i] > arr[mi]:
            mi = i
    return mi

def pancake_sort(arr):
    """
    Основной алгоритм блинной сортировки.
    Сначала ищем максимум, поднимаем его наверх, затем опускаем вниз.
    Процесс повторяется до полной сортировки массива.
    """
    current_size = len(arr)
    while current_size > 1:
        # Находим индекс максимального элемента среди оставшихся элементов
        mi = find_max(arr, current_size)
        
        # Если максимальный элемент находится не на своём месте
        if mi != current_size - 1:
            # Перевернём верхнюю часть массива, чтобы поднять максимальный элемент наверх
            flip(arr, mi)
            
            # Теперь опустим максимальный элемент вниз, сделав ещё один переворот
            flip(arr, current_size - 1)
        
        # Уменьшаем размер неотсортированного участка массива
        current_size -= 1

# Тестирование алгоритма
arr = [3, 6, 2, 4, 5, 1]
print("Исходный массив:", arr)
pancake_sort(arr)
print("Отсортированный массив:", arr)

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Исходный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]
