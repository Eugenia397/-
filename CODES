БЛОЧНАЯ (КОРЗИННАЯ) СОРТИРОВКА
def bucket_sort(arr):
    # Определяем максимальное значение для расчёта количества бакетов
    max_value = max(arr)
    
    # Количество бакетов выбирается исходя из длины массива (можно настраивать)
    num_buckets = len(arr)
    
    # Создаем список пустых списков (каждый пустой список является бакетом)
    buckets_list = []
    for i in range(num_buckets):
        buckets_list.append([])
        
    # Распределяем элементы массива по соответствующим бакетам
    for j in arr:
        index_b = int((j / max_value) * (num_buckets - 1))
        buckets_list[index_b].append(j)
    
    # Сортируем каждый бакет (используем встроенную сортировку Python)
    for i in range(len(buckets_list)):
        buckets_list[i].sort()
    
    # Объединяем отсортированные бакеты в итоговый отсортированный массив
    final_output = []
    for x in buckets_list:
        final_output.extend(x)
    
    return final_output


# Пример запуска программы
if __name__ == "__main__":
    input_array = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
    print("Исходный массив:", input_array)
    sorted_array = bucket_sort(input_array)
    print("Отсортированный массив:", sorted_array)

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Исходный массив: [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
Отсортированный массив: [0.1234, 0.3434, 0.565, 0.656, 0.665, 0.897]





БЛИННАЯ СОРТИРОВКА
def flip(arr, k):
    """
    Функция переворачивает первые k+1 элементов массива arr.
    Например, flip([1, 2, 3], 1) превратится в [2, 1, 3].
    """
    start = 0
    end = k
    while start < end:
        # Меняем местами первый и последний элементы текущего сегмента
        arr[start], arr[end] = arr[end], arr[start]
        start += 1
        end -= 1

def find_max(arr, n):
    """
    Ищет индекс максимального элемента в первых n элементах массива.
    Возвращает индекс самого большого элемента среди первых n элементов.
    """
    mi = 0
    for i in range(1, n):  # Проверяем остальные элементы начиная со второго
        if arr[i] > arr[mi]:
            mi = i
    return mi

def pancake_sort(arr):
    """
    Основной алгоритм блинной сортировки.
    Сначала ищем максимум, поднимаем его наверх, затем опускаем вниз.
    Процесс повторяется до полной сортировки массива.
    """
    current_size = len(arr)
    while current_size > 1:
        # Находим индекс максимального элемента среди оставшихся элементов
        mi = find_max(arr, current_size)
        
        # Если максимальный элемент находится не на своём месте
        if mi != current_size - 1:
            # Перевернём верхнюю часть массива, чтобы поднять максимальный элемент наверх
            flip(arr, mi)
            
            # Теперь опустим максимальный элемент вниз, сделав ещё один переворот
            flip(arr, current_size - 1)
        
        # Уменьшаем размер неотсортированного участка массива
        current_size -= 1

# Тестирование алгоритма
arr = [3, 6, 2, 4, 5, 1]
print("Исходный массив:", arr)
pancake_sort(arr)
print("Отсортированный массив:", arr)

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Исходный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]






СОРТИРОВКА БУСИНАМИ(ГРАВИТАЦИОННАЯ)
def bead_sort(arr):
    """
    Реализует алгоритм сортировки бусинами (gravity bead sort).
    Вход: list of integers
    Выход: отсортированный list
    """
    # Определим максимальную высоту (число бусин в самом высоком столбце)
    max_height = max(arr)
    
    # Создание матрицы размером max_height х len(arr)
    beads_matrix = [[False]*len(arr) for _ in range(max_height)]
    
    # Заполнение матрицы бусинами (True)
    for col in range(len(arr)):      # Обрабатываем каждый столбец
        height = arr[col]           # Высота текущего столбца
        for row in range(height):   # Устанавливаем True для каждой бусины
            beads_matrix[row][col] = True
    
    # Освобождаем нижнюю часть: симулируем падение бусин
    for row in range(max_height):
        count_true = sum(beads_matrix[row])  # считаем количество бусин в строке
        beads_matrix[row][:count_true] = [True]*count_true  # размещаем их слева
        beads_matrix[row][count_true:] = [False]*(len(arr)-count_true)  # очищаем правую сторону
    
    # Читаем матрицу снизу вверх, собирая результат
    result = []
    for col in range(len(arr)):
        # Подсчитываем количество бусин в данном столбце
        height = sum(row[col] for row in beads_matrix)
        result.append(height)
    
    return result

# Пример использования
input_arr = [3, 1, 4, 1]
sorted_arr = bead_sort(input_arr)
print(f"Входной массив: {input_arr}")
print(f"Отсортированный массив: {sorted_arr}")

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Входной массив: [3, 1, 4, 1]
Отсортированный массив: [1, 1, 3, 4]






ПОИСК СКАЧКАМИ
import math
def jump_search(arr, target):
    """
    Реализует алгоритм Jump Search для поиска элемента в отсортированном массиве.
    :param arr: отсортированный массив
    :param target: искомое значение
    :return: индекс искомого элемента или -1, если элемент не найден
    """
    length = len(arr)
    step = int(math.sqrt(length))  # Оптимальное расстояние прыжка
    
    prev = 0
    next_jump = min(step, length)  # Следующая точка прыжка
    
    # Производим скачок вперед по массиву
    while next_jump < length and arr[next_jump] <= target:
        prev = next_jump
        next_jump += step
    
    # Линейный поиск в пределах последней секции
    for idx in range(prev, min(next_jump, length)):
        if arr[idx] == target:
            return idx
    
    return -1  # Элемент не найден

# Пример использования
if __name__ == "__main__":
    data = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
    search_target = 15
    position = jump_search(data, search_target)
    
    if position != -1:
        print(f"Элемент {search_target} найден на позиции {position}.")
    else:
        print(f"Элемент {search_target} не найден.")

Результат Выполнения Кодa:
Элемент 15 найден на позиции 7.






ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Исходный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]





ТЕРНАРНЫЙ ПОИСК

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Исходный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]

