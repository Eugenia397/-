БЛОЧНАЯ (КОРЗИННАЯ) СОРТИРОВКА
Определение:
Блочная (корзинная) сортировка, также известная как Bucket Sort, представляет собой алгоритм сортировки, который распределяет элементы массива по различным контейнерам («бочкам») или корзинам, каждая из которых затем сортируется отдельно.
Этот метод особенно эффективен, когда исходные элементы равномерно распределены в диапазоне значений.

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Исходный массив: [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
Отсортированный массив: [0.1234, 0.3434, 0.565, 0.656, 0.665, 0.897]

Кратко о работе алгоритма:
Алгоритм разделяет элементы массива на разные группы ("бактики") на основании значений, потом сортирует каждую группу отдельно и объединяет отсортированные группы обратно в единое целое.

Описание временной сложности:
BIG-O обозначает верхнюю границу производительности алгоритма. Среднее время исполнения алгоритма равно O(n+k), где n — длина входящего массива, а k — количество бакетов. Это хорошее среднее время, если распределение элементов равномерное.
Однако, если данные сильно сгруппированы в небольшом количестве бакетов, эффективность падает до уровня обычной быстрой сортировки (O(n ^2) в худшем случае).

Краткое объяснение оценки временной сложности алгоритма:





БЛИННАЯ СОРТИРОВКА
Определение:
Блинная сортировка — это интересный алгоритм сортировки, который основан на аналогии с переворачиванием блинов в стопке.
Основная идея заключается в следующем: представьте себе стопку блинов разного размера, которую нужно отсортировать таким образом, чтобы самый большой блин оказался внизу, второй по размеру сверху него и так далее, пока самый маленький блин не окажется вверху.
Единственное действие, которое разрешено в этом процессе — перевернуть верхний слой блинов любым способом.

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Исходный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]

Кратко о работе алгоритма:
Изначально берем всю длину массива и начинаем процесс сортировки.
На каждом этапе определяем максимальный элемент среди оставшихся элементов.
Переворачиваем массив так, чтобы максимальный элемент переместился на первую позицию.## Определение алгоритма блинной сортировки

Описание временной сложности:
Лучшая сложность: O(n) (если массив изначально отсортирован).
Средняя и худшая сложность: O(N^2), так как на каждом шаге мы производим два переворота (линейные операции) и итерации продолжаются до полного завершения процесса.


Краткое объяснение оценки временной сложности алгоритма:
Каждый проход цикла ищет максимум и дважды переворачивает массив, оба действия имеют линейную сложность O(n).
Поскольку таких циклов должно произойти N раз, общая временная сложность составляет O(N^2).





СОРТИРОВКА БУСИНАМИ(ГРАВИТАЦИОННАЯ)
Определение:
Сортировка бусинами (также известна как гравитационная сортировка) — это нестандартный визуализированный алгоритм сортировки целых чисел, основанный на модели физических процессов. Представьте столбцы одинаковых вертикальных нитей, каждая нить покрыта бусынами (шарами), высота которой соответствует числу в массиве.
Затем воображаемые нити позволяют бусинам падать вертикально вниз, формируя устойчивые структуры, после чего считывается новый упорядоченный массив.

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Входной массив: [3, 1, 4, 1]
Отсортированный массив: [1, 1, 3, 4]

Кратко о работе алгоритма:
Представьте, что у вас есть массив [3,1,4,1]:
Столбец №1 содержит три бусины (высота 3),
Столбец №2 содержит одну бусину (высота 1),
Столбец №3 содержит четыре бусины (высота 4),
Столбец №4 содержит одну бусину (высота 1).

Описание временной сложности:
Теоретически и практически временные характеристики зависят от реализаций:
Средняя и худшая временная сложность: O(W∗N), где W — максимальная цифра в массиве, а N — количество элементов в массиве.
Пространственная сложность: O(W∗N), так как необходима дополнительная память для представления матриц "столбцов".
Это связано с тем, что на каждое число тратится время пропорциональное его величине (W), и всего таких чисел N. Соответственно, общее время увеличивается с ростом обоих факторов.

Краткое объяснение оценки временной сложности алгоритма:
Основной фактор замедления алгоритма — необходимость прохождения по двум измерениям (строкам и столбцам) матрицы. 
Размер матрицы пропорционален произведению двух величин: длине массива (N) и самой большой цифре (W). 
Из-за этого средняя и худшая временная сложность составляет O(W∗N).







ПОИСК СКАЧКАМИ
Определение:
Поиск скачками (Jump Search) — это гибридный алгоритм поиска, который сочетает в себе идеи линейного и бинарного поисков.
Его основная цель — уменьшить количество сравнений, необходимых для нахождения элемента в отсортированном массиве.

Результат Выполнения Кодa:
Элемент 15 найден на позиции 7.

Кратко о работе алгоритма:
Рассмотрим подробнее работу примера:
Дана отсортированная последовательность: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
Целевой элемент — 15.
Длина массива — 11, оптимальная величина прыжка — √11 ≈ 3.
Первые прыжки происходят на индексы: 3 → 6 → 9.
Значение на индексе 9 (19) больше цели (15), значит, искомый элемент находится в промежутке от предыдущего прыжка (6-й индекс) до текущего (9-го индекса).
Проведя линейный поиск в этом диапазоне, находим нужный элемент на позиции 7.


Описание временной сложности:
Лучший случай: O(кореньN), где N — длина массива.
Худший случай: $\mathbf{O(\sqrt{N})$, при условии оптимального выбора размера прыжка.

Краткое объяснение оценки временной сложности алгоритма:
Почему кореньN? Потому что оптимальное расстояние прыжков в отсортированном массиве равно корню из размера массива, что минимизирует количество проверок.





ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК
Определение:

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Исходный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]

Кратко о работе алгоритма:

Описание временной сложности:

Краткое объяснение оценки временной сложности алгоритма:





ТЕРНАРНЫЙ ПОИСК
Определение:

Результат Выполнения Кодa:
Предположим, вводим следующий массив чисел:
Исходный массив: [3, 6, 2, 4, 5, 1]
Отсортированный массив: [1, 2, 3, 4, 5, 6]

Кратко о работе алгоритма:

Описание временной сложности:

Краткое объяснение оценки временной сложности алгоритма:






