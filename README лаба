Анализ алгоритма: Сортировка выбором (Selection Sort)
Определение:
Сортировка выбором (Selection Sort) представляет собой метод сортировки, который последовательно делит массив на два сегмента: отсортированный и неотсортированный.
Алгоритм работает путем нахождения наименьшего элемента в неотсортированном сегменте и замены его с первым элементом этого сегмента.
Анализ:
Алгоритм находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом в неотсортированной части.
Внешний цикл for выполняется n-1 раз.
Внутренний цикл for в худшем случае выполняется n-1, затем n-2, ..., раз за каждый проход внешнего цикла.
Общее количество сравнений примерно равно n*(n-1)/2.
Временная сложность: O(n²)
Почему O(n²): 
Это объясняется наличием двух циклов, где внешний цикл повторяется n-1 раз, а внутренний цикл постепенно уменьшает количество проверок от n-1 до 1. 
Поскольку внутреннее сравнение выполняется пропорционально количеству оставшегося несортированного массива, общая временная сложность становится квадратичной относительно размера входного набора данных.



Анализ алгоритма: Сортировка обменом (пузырьком) (Bubble Sort)
Определение:
Сортировка обменом является простым методом сортировки, который неоднократно проходит по списку, сравнивая последовательные элементы и меняя их местами, если они нарушают порядок сортировки.
Анализ:
Алгоритм проходит по массиву, сравнивая соседние элементы и меняя их местами, если левый больше правого. Это "всплывание" самого большого элемента в конец.
Внешний цикл for выполняется n-1 раз.
Внутренний цикл for в худшем случае (когда массив отсортирован в обратном порядке) выполняется n-1, затем n-2, ..., раз.
Оптимизация с флагом swapped позволяет выйти из цикла раньше, если массив уже отсортирован.
Временная сложность: O(n²)
Почему O(n²): 
Алгоритм состоит из двух вложенных циклов:
Внешний цикл выполняется (n−1) раз.
Внутренний цикл на первом проходе совершает (n−1) сравнений, на втором проходе — (n−2), и так далее вплоть до одного сравнения.



Анализ алгоритма: Сортировка вставками (Insertion Sort)
Определение:
Сортировка вставками (Insertion Sort) — это алгоритм, который обрабатывает элементы входящей последовательности поочередно, помещая каждый новый элемент в соответствующее положение среди тех элементов, которые уже были отсортированы.
Анализ:
Алгоритм строит отсортированную часть списка, начиная с первого элемента. Каждый новый элемент вставляется в правильное место среди уже отсортированных.
Внешний цикл for проходит по всем элементам массива, исключая первый, то есть выполняется n-1 раз.
Внутренний цикл while в худшем случае (массив отсортирован в обратном порядке) может выполнить до i итераций на i-ой итерации внешнего цикла.
Временная сложность:
Худший случай: O(n²). Наступает, когда массив отсортирован в обратном порядке. Каждый новый элемент должен пройти максимальное расстояние до своего места.
Лучший случай: O(n). Реализуется, когда массив уже отсортирован заранее, и внутренний цикл не выполняется вообще.
Средний случай: O(n²)
Почему O(n²): В худшем случае общее количество сдвигов и сравнений составляет 1 + 2 + 3 + ... + (n-1) = n*(n-1)/2.



Анализ алгоритма: Сортировка слиянием (Merge Sort)
Определение:
Сортировка слиянием (Merge Sort) представляет собой метод сортировки, предназначенный для упорядочивания списков или последовательных структур данных таким образом, чтобы обеспечить стабильную последовательность элементов.  
Анализ:
Принцип работы заключается в разделении исходного массива на две половины рекурсивно, пока каждый сегмент не станет состоять из единственного элемента. Затем происходит объединение полученных сегментов обратно, используя процедуру объединения (merge), которая эффективно комбинирует два предварительно отсортированных сегмента в единый отсортированный массив большего размера.  
Временная сложность:
O(n log n)
Почему O(n log n): 
Разделение массива: Разбиение массива на подмассивы продолжается рекурсивно до уровня единичных элементов. 
Глубина рекурсии равна log2n, поскольку массив делится ровно напополам на каждой итерации.  
Объединение частей: Процедура merge работает линейно относительно общего количества элементов (n), объединяя отсортированные части вместе на каждом этапе рекурсии.
Таким образом, на каждом уровне выполняется работа порядка O(n).  
Общее количество шагов: Умножая глубину рекурсии (log2n) на объем работы на каждом уровне (n), получаем итоговую временную сложность O(nlogn) — оптимально эффективную для большинства случаев.



Анализ алгоритма: Сортировка Шелла (Shell Sort)
Определение:
Сортировка Шелла является улучшенной версией обычной сортировки вставками.
Её основная идея заключается в сравнении и обмене элементов, находящихся не непосредственно рядом, а на некотором фиксированном расстоянии ("gap").
Это позволяет быстрее приводить список к частично упорядоченному состоянию перед финальной фазой стандартной сортировки вставками.
Анализ:
Алгоритм реализуется следующим образом: изначально выбирается некоторое начальное значение промежутка (gap), и элементы списка, расположенные на этом расстоянии друг от друга, сортируются методом вставок.
Далее промежуток уменьшается, и процедура повторяется заново.
Такой подход позволяет быстро приближать элементы ближе к своим конечным позициям ещё до завершения полной сортировки.
Временная сложность:
Общая временная сложность Shell Sort варьируется в зависимости от конкретной последовательности промежутков.
Для последовательности, используемой в коде (n/2^k), сложность составляет O(n^(3/2)) или O(n log² n) в среднем случае, но может быть хуже.
В худшем случае (для некоторых последовательностей) может быть O(n²).
Для последовательности Кнута (gap = 3h + 1) сложность составляет O(n^(3/2)).
В целом, точная сложность часто выражается как O(n^p), где 1 < p <= 2.
Почему O(n^p): 
Несмотря на наличие двух вложенных циклов, внутренние проходы (цикл по переменной j) выполняются гораздо реже полного перебора всех элементов, как это было бы в простой сортировке вставками.
Поскольку на ранних этапах элементы расположены далеко друг от друга и нуждаются лишь в небольшом количестве перестановок, общее число сравнений и перемещений растёт значительно медленнее, чем квадратично.
В результате средняя временная сложность лежит между линейной (O(n)) и квадратичной (O(n^2)), выражаясь формулой O(n^p), где показатель степени p зависит от выбора последовательности промежутков.



Анализ алгоритма: Быстрая сортировка (Quick Sort)
Определение:
Быстрая сортировка (Quick Sort) — это эффективный алгоритм сортировки, который использует принцип «разделяй и властвуй».
Анализ:
Выбирается опорный элемент. Массив перераспределяется так, что элементы, меньшие или равные опорному, оказываются слева от него, а большие — справа.
Затем рекурсивно сортируются левая и правая части.
Выбор опорного элемента критичен для производительности.
Временная сложность:
Средний случай: O(n log n) — если опорный элемент делит массив примерно пополам на каждом шаге.
Худший случай: O(n²) — если опорный элемент всегда является минимальным или максимальным (например, массив уже отсортирован, и опорный всегда последний). В этом случае дерево рекурсии имеет глубину n, а на каждом уровне выполняется n сравнений.
Лучший случай: O(n log n) — если опорный всегда делит массив ровно пополам.
Почему O(n log n) или O(n²):
Средний/Лучший: Глубина рекурсии log n, на каждом уровне n сравнений (в partition). n * log n.
Худший: Глубина рекурсии n, на каждом уровне до n, n-1, n-2, ... сравнений. n + (n-1) + ... + 1 = n(n+1)/2 ≈ O(n²)



Анализ алгоритма: Пирамидальная сортировка (Heap Sort)
Определение:
Пирамидальная сортировка (Heap Sort) — это эффективный алгоритм сортировки, основанный на структуре данных бинарная куча (heap).
Анализ:
Сначала строится max-heap (бинарное дерево, где родитель >= детей).
Затем максимальный элемент (корень) извлекается и помещается в конец массива. Куча уменьшается, и свойство heap восстанавливается для оставшейся части.
Временная сложность: O(n log n)
Почему O(n log n):
Построение кучи: build_max_heap выполняет heapify для n/2 узлов. Каждый вызов heapify может иметь глубину log n. В сумме это O(n) (доказывается математически, так как большинство узлов находятся ближе к листьям).
Сортировка: Цикл for выполняется n-1 раз. Внутри него вызывается heapify, который работает за O(log n) (глубина дерева). Итого n * O(log n) = O(n log n).
Общая сложность: O(n) (построение) + O(n log n) (сортировка) = O(n log n).



Анализ алгоритма: Последовательный поиск (Linear Search)
Определение:
Последовательный (линейный) поиск — это метод поиска элемента в списке или массиве путем последовательного просмотра каждого элемента, начиная с первого, до нахождения искомого значения или достижения конца списка.
Анализ:
Алгоритм последовательно перебирает элементы массива, осуществляя сравнение каждого из них с заданным искомым значением.
Временная сложность:
Худший случай: O(n) — элемент находится в конце массива или отсутствует.
Лучший случай: O(1) — элемент находится в начале массива.
Средний случай: O(n/2) ≈ O(n)
Почему O(n): Иначе, в худшем случае предёться проверять все n элементов.



Анализ алгоритма: Бинарный поиск (Binary Search)
Определение:
Бинарный поиск (Binary Search) — это метод поиска элемента в заранее отсортированной коллекции данных (обычно массиве).
Анализ:
Алгоритм применим исключительно к упорядоченным данным.
Работа осуществляется посредством деления области поиска пополам на каждом шаге: центральный элемент сравнивается с искомым значением, и в зависимости от результата исключаются либо левая, либо правая половина массива.
Временная сложность: Средняя и максимальная сложность бинарного поиска составляют O(log n)
Почему O(log n): При каждом шаге область поиска сокращается примерно вдвое. 
Следовательно, количество шагов, необходимое для уменьшения диапазона поиска от n элементов до одного, пропорционально логарифму числа элементов по основанию 2(log₂ n).



Анализ алгоритма: Интерполирующий поиск (Interpolation Search)
Определение:
Интерполирующий поиск (interpolation search) — это усовершенствованный вариант бинарного поиска, применяемый преимущественно для больших отсортированных численных массивов с равномерным распределением элементов.
Анализ:
Аналогичен бинарному поиску, однако вместо механического разделения на равные части, рассчитывает приблизительное положение искомого элемента исходя из его значения и границ текущего интервала, полагаясь на предположение о равномерном распределении элементов.
Временная сложность:
Средний случай (равномерное распределение): O(log log n)
Худший случай (неравномерное распределение): O(n)
Почему O(log log n) или O(n):
Средний: При равномерном распределении, на каждом шаге размер области поиска уменьшается быстрее, чем в бинарном поиске. Количество шагов приблизительно равно log log n.
Худший: Если данные распределены неравномерно (например, большинство элементов сосредоточено в начале), pos может вычисляться близко к lo, и алгоритм может деградировать до линейного сканирования, проверяя каждый элемент по одному.



Анализ алгоритма: Поиск по Фибоначчи (Fibonacci Search)
Определение:
Поиск методом Фибоначчи (Fibonacci Search) — это специализированный алгоритм поиска в отсортированном массиве, использующий числа Фибоначчи для эффективного разделения пространства поиска.
Анализ:
Применяет ряд чисел Фибоначчи для задания промежуточных позиций при разбиении массива, подобно бинарному поиску, который также делит пространство поиска на части, но пропорции разбиения отличаются.
Временная сложность: O(log n)
Почему O(log n): Количество чисел Фибоначчи до n примерно равно log n. Каждая итерация цикла while уменьшает размер области поиска, используя меньшие числа Фибоначчи, что приводит к O(log n) итераций.


