БЛОЧНАЯ (КОРЗИННАЯ) СОРТИРОВКА
def bucket_sort(arr):
    # Определяем максимальное значение для расчёта количества бакетов
    max_value = max(arr)
    
    # Количество бакетов выбирается исходя из длины массива (можно настраивать)
    num_buckets = len(arr)
    
    # Создаем список пустых списков (каждый пустой список является бакетом)
    buckets_list = []
    for i in range(num_buckets):
        buckets_list.append([])
        
    # Распределяем элементы массива по соответствующим бакетам
    for j in arr:
        index_b = int((j / max_value) * (num_buckets - 1))
        buckets_list[index_b].append(j)
    
    # Сортируем каждый бакет (используем встроенную сортировку Python)
    for i in range(len(buckets_list)):
        buckets_list[i].sort()
    
    # Объединяем отсортированные бакеты в итоговый отсортированный массив
    final_output = []
    for x in buckets_list:
        final_output.extend(x)
    
    return final_output

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
if __name__ == "__main__":
    input_array = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
    print("Исходный массив:", input_array)
    sorted_array = bucket_sort(input_array)
    print("Отсортированный массив:", sorted_array)







БЛИННАЯ СОРТИРОВКА
def pancake_sort(arr):
    """
    Реализует алгоритм блинной сортировки.
    :param arr: массив целых чисел
    :return: отсортированный массив
    """
    remaining_length = len(arr)
    
    while remaining_length > 1:
        # Находим индекс максимального элемента в текущей части массива
        max_idx = arr.index(max(arr[:remaining_length]))
        
        # Переворачиваем подмассив до максимального элемента
        arr[:max_idx+1] = reversed(arr[:max_idx+1])
        
        # Переворачиваем весь подмассив, чтобы максимальный элемент попал в конец
        arr[:remaining_length] = reversed(arr[:remaining_length])
        
        # Уменьшаем размер неотсортированной части массива
        remaining_length -= 1
    
    return arr

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
if __name__ == "__main__":
    test_array = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
    sorted_result = pancake_sort(test_array)
    print("Исходный массив:", test_array)
    print("Отсортированный массив:", sorted_result)








СОРТИРОВКА БУСИНАМИ(ГРАВИТАЦИОННАЯ)
def gravity_bead_sort(arr):
    """
    Реализует алгоритм сортировки бусинами (гравитационной сортировки).
    :param arr: массив целых чисел
    :return: отсортированный массив
    """
    # Максимальная высота (значение) в массиве
    max_value = max(arr)
    
    # Преобразование массива в булеву матрицу бусин
    beads_matrix = [[value > i for i in range(max_value)] for value in arr]
    
    # Трансформация матрицы для эмуляции «падения»
    transposed = list(zip(*beads_matrix))
    
    # Имитация «падения бусин»
    for column in transposed:
        column.sort(reverse=True)
    
    # Обратная трансформация и подсчет количества бусин в каждой строке
    sorted_arr = [sum(row) for row in zip(*transposed)]
    
    return sorted_arr

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
if __name__ == "__main__":
    test_array = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
    sorted_result = gravity_bead_sort(test_array)
    print("Исходный массив:", test_array)
    print("Отсортированный массив:", sorted_result)








ПОИСК СКАЧКАМИ
import math
def jump_search(arr, target):
    """
    Реализует алгоритм Jump Search для поиска элемента в отсортированном массиве.
    :param arr: отсортированный массив
    :param target: искомое значение
    :return: индекс искомого элемента или -1, если элемент не найден
    """
    length = len(arr)
    step = int(math.sqrt(length))  # Оптимальное расстояние прыжка
    
    prev = 0
    next_jump = min(step, length)  # Следующая точка прыжка
    
    # Производим скачок вперед по массиву
    while next_jump < length and arr[next_jump] <= target:
        prev = next_jump
        next_jump += step
    
    # Линейный поиск в пределах последней секции
    for idx in range(prev, min(next_jump, length)):
        if arr[idx] == target:
            return idx
    
    return -1  # Элемент не найден

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
if __name__ == "__main__":
    data = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
    search_target = 15
    position = jump_search(data, search_target)
    
    if position != -1:
        print(f"Элемент {search_target} найден на позиции {position}.")
    else:
        print(f"Элемент {search_target} не найден.")








ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК
def binary_search(arr, left, right, target):
    """
    Вспомогательная функция для бинарного поиска.
    """
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

def exponential_search(arr, target):
    """
    Реализует экспоненциальный поиск в отсортированном массиве.
    """
    if not arr or arr[0] > target:
        return -1  # Если массив пуст или первый элемент больше искомого
    
    # Экспоненциальное расширение
    bound = 1
    while bound < len(arr) and arr[bound] < target:
        bound *= 2
    
    # Бинарный поиск в найденном диапазоне
    return binary_search(arr, bound//2, min(bound, len(arr)-1), target)

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
target = 15
result = exponential_search(arr, target)

if result != -1:
    print(f"Элемент {target} найден на позиции {result}.")
else:
    print(f"Элемент {target} не найден.")






ТЕРНАРНЫЙ ПОИСК
def ternary_search(arr, target):
    """
    Реализует тернарный поиск в отсортированном массиве.
    :param arr: отсортированный массив
    :param target: искомое значение
    :return: индекс искомого элемента или -1, если элемент не найден
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        # Делим массив на три примерно равные части
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        
        # Проверяем средние точки
        if arr[mid1] == target:
            return mid1
        elif arr[mid2] == target:
            return mid2
        
        # Узкая настройка областей поиска
        if target < arr[mid1]:
            right = mid1 - 1
        elif target > arr[mid2]:
            left = mid2 + 1
        else:
            left = mid1 + 1
            right = mid2 - 1
    
    return -1  # Элемент не найден

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
test_array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
target_value = 15
result = ternary_search(test_array, target_value)

if result != -1:
    print(f"Элемент {target_value} найден на позиции {result}.")
else:
    print(f"Элемент {target_value} не найден.")

