БЛОЧНАЯ (КОРЗИННАЯ) СОРТИРОВКА
def bucket_sort(arr):
    # Определяем максимальное значение для расчёта количества бакетов
    max_value = max(arr)
    
    # Количество бакетов выбирается исходя из длины массива (можно настраивать)
    num_buckets = len(arr)
    
    # Создаем список пустых списков (каждый пустой список является бакетом)
    buckets_list = []
    for i in range(num_buckets):
        buckets_list.append([])
        
    # Распределяем элементы массива по соответствующим бакетам
    for j in arr:
        index_b = int((j / max_value) * (num_buckets - 1))
        buckets_list[index_b].append(j)
    
    # Сортируем каждый бакет (используем встроенную сортировку Python)
    for i in range(len(buckets_list)):
        buckets_list[i].sort()
    
    # Объединяем отсортированные бакеты в итоговый отсортированный массив
    final_output = []
    for x in buckets_list:
        final_output.extend(x)
    
    return final_output

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
if __name__ == "__main__":
    input_array = [0.897, 0.565, 0.656, 0.1234, 0.665, 0.3434]
    print("Исходный массив:", input_array)
    sorted_array = bucket_sort(input_array)
    print("Отсортированный массив:", sorted_array)







БЛИННАЯ СОРТИРОВКА
def flip(arr, k):
    """
    Функция переворачивает первые k+1 элементов массива arr.
    Например, flip([1, 2, 3], 1) превратится в [2, 1, 3].
    """
    start = 0
    end = k
    while start < end:
        # Меняем местами первый и последний элементы текущего сегмента
        arr[start], arr[end] = arr[end], arr[start]
        start += 1
        end -= 1

def find_max(arr, n):
    """
    Ищет индекс максимального элемента в первых n элементах массива.
    Возвращает индекс самого большого элемента среди первых n элементов.
    """
    mi = 0
    for i in range(1, n):  # Проверяем остальные элементы начиная со второго
        if arr[i] > arr[mi]:
            mi = i
    return mi

def pancake_sort(arr):
    """
    Основной алгоритм блинной сортировки.
    Сначала ищем максимум, поднимаем его наверх, затем опускаем вниз.
    Процесс повторяется до полной сортировки массива.
    """
    current_size = len(arr)
    while current_size > 1:
        # Находим индекс максимального элемента среди оставшихся элементов
        mi = find_max(arr, current_size)
        
        # Если максимальный элемент находится не на своём месте
        if mi != current_size - 1:
            # Перевернём верхнюю часть массива, чтобы поднять максимальный элемент наверх
            flip(arr, mi)
            
            # Теперь опустим максимальный элемент вниз, сделав ещё один переворот
            flip(arr, current_size - 1)
        
        # Уменьшаем размер неотсортированного участка массива
        current_size -= 1

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
arr = [3, 6, 2, 4, 5, 1]
print("Исходный массив:", arr)
pancake_sort(arr)
print("Отсортированный массив:", arr)








СОРТИРОВКА БУСИНАМИ(ГРАВИТАЦИОННАЯ)
def gravity_bead_sort(arr):
    """
    Реализует алгоритм сортировки бусинами (гравитационной сортировки).
    :param arr: массив целых чисел
    :return: отсортированный массив
    """
    # Максимальная высота (значение) в массиве
    max_value = max(arr)
    
    # Преобразование массива в булеву матрицу бусин
    beads_matrix = [[value > i for i in range(max_value)] for value in arr]
    
    # Трансформация матрицы для эмуляции «падения»
    transposed = list(zip(*beads_matrix))
    
    # Имитация «падения бусин»
    for column in transposed:
        column.sort(reverse=True)
    
    # Обратная трансформация и подсчет количества бусин в каждой строке
    sorted_arr = [sum(row) for row in zip(*transposed)]
    
    return sorted_arr

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
if __name__ == "__main__":
    test_array = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
    sorted_result = gravity_bead_sort(test_array)
    print("Исходный массив:", test_array)
    print("Отсортированный массив:", sorted_result)








ПОИСК СКАЧКАМИ
import math
def jump_search(arr, target):
    """
    Реализует алгоритм Jump Search для поиска элемента в отсортированном массиве.
    :param arr: отсортированный массив
    :param target: искомое значение
    :return: индекс искомого элемента или -1, если элемент не найден
    """
    length = len(arr)
    step = int(math.sqrt(length))  # Оптимальное расстояние прыжка
    
    prev = 0
    next_jump = min(step, length)  # Следующая точка прыжка
    
    # Производим скачок вперед по массиву
    while next_jump < length and arr[next_jump] <= target:
        prev = next_jump
        next_jump += step
    
    # Линейный поиск в пределах последней секции
    for idx in range(prev, min(next_jump, length)):
        if arr[idx] == target:
            return idx
    
    return -1  # Элемент не найден

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
if __name__ == "__main__":
    data = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
    search_target = 15
    position = jump_search(data, search_target)
    
    if position != -1:
        print(f"Элемент {search_target} найден на позиции {position}.")
    else:
        print(f"Элемент {search_target} не найден.")








ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК
def binary_search(arr, left, right, target):
    """
    Вспомогательная функция для бинарного поиска.
    """
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

def exponential_search(arr, target):
    """
    Реализует экспоненциальный поиск в отсортированном массиве.
    """
    if not arr or arr[0] > target:
        return -1  # Если массив пуст или первый элемент больше искомого
    
    # Экспоненциальное расширение
    bound = 1
    while bound < len(arr) and arr[bound] < target:
        bound *= 2
    
    # Бинарный поиск в найденном диапазоне
    return binary_search(arr, bound//2, min(bound, len(arr)-1), target)

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
target = 15
result = exponential_search(arr, target)

if result != -1:
    print(f"Элемент {target} найден на позиции {result}.")
else:
    print(f"Элемент {target} не найден.")






ТЕРНАРНЫЙ ПОИСК
def ternary_search(arr, target):
    """
    Реализует тернарный поиск в отсортированном массиве.
    :param arr: отсортированный массив
    :param target: искомое значение
    :return: индекс искомого элемента или -1, если элемент не найден
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        # Делим массив на три примерно равные части
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        
        # Проверяем средние точки
        if arr[mid1] == target:
            return mid1
        elif arr[mid2] == target:
            return mid2
        
        # Узкая настройка областей поиска
        if target < arr[mid1]:
            right = mid1 - 1
        elif target > arr[mid2]:
            left = mid2 + 1
        else:
            left = mid1 + 1
            right = mid2 - 1
    
    return -1  # Элемент не найден

РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ КОДА:
test_array = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21]
target_value = 15
result = ternary_search(test_array, target_value)

if result != -1:
    print(f"Элемент {target_value} найден на позиции {result}.")
else:
    print(f"Элемент {target_value} не найден.")

