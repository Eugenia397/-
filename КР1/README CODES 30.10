БЛОЧНАЯ (КОРЗИННАЯ) СОРТИРОВКА
1) Определение:
Блочная (корзинная) сортировка, также известная как Bucket Sort, представляет собой алгоритм сортировки, который распределяет элементы массива по различным контейнерам («бочкам») или корзинам, каждая из которых затем сортируется отдельно.
Этот метод особенно эффективен, когда исходные элементы равномерно распределены в диапазоне значений.

2) Кратко о работе алгоритма:
1. Определяется количество корзин.
num_buckets = len(arr)
2. Каждый элемент помещается в корзину согласно функции распределения.
index_b = int((j / max_value) * (num_buckets - 1))
        buckets_list[index_b].append(j)
3. Содержимое каждой корзины сортируется индивидуально.
for i in range(len(buckets_list)):
        buckets_list[i].sort()
4. Объединяем отсортированные бакеты в итоговый отсортированный массив.
final_output = []
    for x in buckets_list:
        final_output.extend(x)

3) Описание временной сложности:
BIG-O обозначает верхнюю границу производительности алгоритма. 
Среднее время исполнения алгоритма равно O(n+k), где n — длина входящего массива, а k — количество бакетов. Это хорошее среднее время, если распределение элементов равномерное.
Однако, если данные сильно сгруппированы в небольшом количестве бакетов, эффективность падает до уровня обычной быстрой сортировки (O(n ^2) в худшем случае).

4) Краткое объяснение оценки временной сложности алгоритма:
Алгоритм разделяет элементы массива на разные группы ("бактики") на основании значений, потом сортирует каждую группу отдельно и объединяет отсортированные группы обратно в единое целое.





БЛИННАЯ СОРТИРОВКА
1) Определение:
Блинная сортировка — это интересный алгоритм сортировки, который основан на аналогии с переворачиванием блинов в стопке.
Основная идея заключается в следующем: представьте себе стопку блинов разного размера, которую нужно отсортировать таким образом, чтобы самый большой блин оказался внизу, второй по размеру сверху него и так далее, пока самый маленький блин не окажется вверху.
Единственное действие, которое разрешено в этом процессе — перевернуть верхний слой блинов любым способом.

2) Кратко о работе алгоритма:
1. Найти максимальный элемент в неотсортированной части массива:
max_idx = arr.index(max(arr[:remaining_length]))
2. Перевернуть подмассив от начала до позиции максимального элемента, чтобы этот элемент оказался первым:
arr[:max_idx+1] = reversed(arr[:max_idx+1])
3. Перевернуть весь подмассив, чтобы максимальный элемент оказался в конце:
arr[:remaining_length] = reversed(arr[:remaining_length])
4. Повторить процесс для оставшейся неотсортированной части массива:
remaining_length -= 1

3) Описание временной сложности:
Средняя сложность: O(N^2), так как на каждом шаге мы производим два переворота (линейные операции) и итерации продолжаются до полного завершения процесса.

4) Краткое объяснение оценки временной сложности алгоритма:
Каждый проход цикла ищет максимум и дважды переворачивает массив, оба действия имеют линейную сложность O(n).
Поскольку таких циклов должно произойти N раз, общая временная сложность составляет O(N^2).





СОРТИРОВКА БУСИНАМИ(ГРАВИТАЦИОННАЯ)
1) Определение:
Сортировка бусинами (также известна как гравитационная сортировка) — это нестандартный визуализированный алгоритм сортировки целых чисел, основанный на модели физических процессов. Представьте столбцы одинаковых вертикальных нитей, каждая нить покрыта бусынами (шарами), высота которой соответствует числу в массиве.
Затем воображаемые нити позволяют бусинам падать вертикально вниз, формируя устойчивые структуры, после чего считывается новый упорядоченный массив.

2) Кратко о работе алгоритма:
1. Каждый элемент массива представляется в виде горизонтального ряда бусин, количество которых соответствует его значению:
beads_matrix = [[value > i for i in range(max_value)] for value in arr]
2. Бусины располагаются на «стержнях»:
transposed = list(zip(*beads_matrix))
3. Под действием «гравитации» бусины падают вниз:
for column in transposed:
    column.sort(reverse=True)
4. После оседания бусин строки считываются сверху вниз — получается отсортированный массив:
sorted_arr = [sum(row) for row in zip(*transposed)]

3) Описание временной сложности:
Теоретически и практически временные характеристики зависят от реализаций:
Средняя временная сложность: O(W∗N), где W — максимальная цифра в массиве, а N — количество элементов в массиве.
Пространственная сложность: O(W∗N), так как необходима дополнительная память для представления матриц "столбцов".
Это связано с тем, что на каждое число тратится время пропорциональное его величине (W), и всего таких чисел N. Соответственно, общее время увеличивается с ростом обоих факторов.

4) Краткое объяснение оценки временной сложности алгоритма:
Основной фактор замедления алгоритма — необходимость прохождения по двум измерениям (строкам и столбцам) матрицы. 
Размер матрицы пропорционален произведению двух величин: длине массива (N) и самой большой цифре (W). 
Из-за этого средняя и худшая временная сложность составляет O(W∗N).







ПОИСК СКАЧКАМИ
1) Определение:
Поиск скачками (Jump Search) — это гибридный алгоритм поиска, который сочетает в себе идеи линейного и бинарного поисков.
Его основная цель — уменьшить количество сравнений, необходимых для нахождения элемента в отсортированном массиве.

2) Кратко о работе алгоритма:
1. Делится массив на блоки длины m=n:
block_size = int(math.sqrt(len(arr)))
2. Алгоритм прыгает вперёд на m элементов, пока не найдёт элемент, больше или равный искомому:
prev_block = 0
while arr[min(block_size, len(arr)-1)] < target:
    prev_block = block_size
    block_size += block_size
3. Если найденный элемент больше искомого, выполняется линейный поиск в предыдущем блоке:
for i in range(prev_block, min(block_size, len(arr))):
    if arr[i] == target:
        return i

3) Описание временной сложности:
Лучший случай: O(кореньN), где N — длина массива.

4) Краткое объяснение оценки временной сложности алгоритма:
Почему кореньN? Потому что оптимальное расстояние прыжков в отсортированном массиве равно корню из размера массива, что минимизирует количество проверок.





ЭКСПОНЕНЦИАЛЬНЫЙ ПОИСК
1) Определение:
Экспоненциальный поиск — это эффективный алгоритм поиска в отсортированных массивах, сочетающий преимущества экспоненциального подхода и классического бинарного поиска.
Вместо прямого перехода к бинарному поиску, алгоритм вначале осуществляет быстрый предварительный поиск с увеличением дистанции экспоненциально, сокращая потенциальный диапазон возможных позиций для дальнейшего точного поиска.

2) Кратко о работе алгоритма:
1. Проверяется первый элемент массива:
if arr[0] > target:
    return -1  # Если первый элемент больше искомого, поиск прекращается
2. Увеличение диапазона экспоненциально:
bound = 1
while bound < len(arr) and arr[bound] < target:
    bound *= 2  # Экспоненциальное увеличение шага (1, 2, 4, 8, ...)
3. Выполнение бинарного поиска на найденном диапазоне:
result = binary_search(arr, bound//2, min(bound, len(arr)-1), target)

3) Временная сложность:
Средняя временная сложность: O(log i), где i — индекс искомого элемента в массиве.

Описание временной сложности:
Первоначальный экспоненциальный поиск достигает требуемой позиции за O(logi) шагов, где i — позиция искомого элемента.
Затем обычный бинарный поиск выполняется на меньшем участке массива, также занимая O(logi) времени.

4) Краткое объяснение оценки временной сложности алгоритма:
Экспоненциальный поиск включает два этапа:
Экспоненциальное передвижение: занимает O(log i) шагов, где i — индекс искомого элемента.
Бинарный поиск: также выполняется за O(log i).






ТЕРНАРНЫЙ ПОИСК
1) Определение:
Тернарный поиск — это разновидность дихотомического поиска (binary search), но вместо деления пополам он делит исследуемый диапазон на три части и выбирает лучшую треть для продолжения поиска.
Чаще всего применяется для нахождения экстремума (максимума или минимума) выпуклой функции, где функция монотонна до определенного момента, а затем убывает или наоборот.

2) Кратко о работе алгоритма:
1. Делится диапазон индексов на три части:
mid1 = left + (right - left) // 
mid2 = right - (right - left) // 3
2. Сравнивается искомый элемент с элементами на двух разделительных границах:
if arr[mid1] == target:
        return mid1el
if arr[mid2] == target:    
        return mid2
3. Если совпадение не найдено, алгоритм повторяется рекурсивно в одной из трёх частей массива, где может находиться искомое значение:
if target < arr[mid1]:    
        right = mid1 - 1
elif target > arr[mid2]:    
left = mid2 + 1
else:    
        left = mid1 + 1    
        right = mid2 - 1

3) Временная сложность:
Средняя временная сложность: 
O(log 3 N), где N — длина массива или область поиска.

4) Краткое объяснение оценки временной сложности алгоритма:
Тернарный поиск на каждом шаге делит диапазон на три части, оставляя одну треть для дальнейших исследований.
Это обеспечивает ускоренное уменьшение области поиска по сравнению с полным обходом, приводя к временной сложности O(log 3 N).





