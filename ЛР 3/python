1) БИНАРНАЯ КУЧА
import heapq

def binary_heap_demo():
    min_heap = []  # Инициализация пустого минимума-кучи
    values = [10, 5, 8, 15]
    
    for v in values:
        heapq.heappush(min_heap, v)  # Pushing each value into the heap
    
    # Extract and display minimum values from the heap
    sorted_values = [heapq.heappop(min_heap) for _ in range(len(values))]
    print(sorted_values)

if __name__ == "__main__":
    binary_heap_demo()



2) БИНОМИНАЛЬНАЯ КУЧА
class BinomialTree:
    def __init__(self, key):
        self.key = key
        self.children = []

class BinomialHeap:
    def __init__(self):
        self.trees = []

    def insert(self, key):
        new_tree = BinomialTree(key)
        new_heap = BinomialHeap()
        new_heap.trees.append(new_tree)
        self.merge(new_heap)

    def merge(self, other):
        result_trees = []
        carry = None
        i = j = 0
        while i < len(self.trees) or j < len(other.trees) or carry:
            t1 = self.trees[i].children if i < len(self.trees) else None
            t2 = other.trees[j].children if j < len(other.trees) else None
            
            if t1 and t2:
                if t1[0].key <= t2[0].key:
                    result_trees.append(t1.pop())
                else:
                    result_trees.append(t2.pop())
            elif t1:
                result_trees.append(t1.pop())
            elif t2:
                result_trees.append(t2.pop())
                
            i += 1
            j += 1
        
        self.trees = result_trees



3) КУЧА ФИБОНАЧЧИ
class FibonacciHeapNode:
    def __init__(self, key):
        self.key = key
        self.parent = None
        self.child = None
        self.left = None
        self.right = None
        self.degree = 0
        self.marked = False

class FibonacciHeap:
    def __init__(self):
        self.min_node = None
        self.size = 0

    def insert(self, key):
        node = FibonacciHeapNode(key)
        if self.min_node is None:
            self.min_node = node
        else:
            self._add_to_root_list(node)
            if node.key < self.min_node.key:
                self.min_node = node
        self.size += 1

    def _add_to_root_list(self, node):
        if self.min_node is None:
            node.left = node.right = node
            self.min_node = node
        else:
            node.right = self.min_node.right
            node.left = self.min_node
            self.min_node.right.left = node
            self.min_node.right = node
            if node.key < self.min_node.key:
                self.min_node = node

    def extract_min(self):
        # Функция экстракции минимального элемента
        pass

    def decrease_key(self, node, new_value):
        # Функционал уменьшения ключа
        pass

    def delete(self, node):
        # Возможность удалить узел
        pass




4) ХЭШ-ТАБЛИЦА
# Создадим простую хэш-таблицу с тремя элементами
hash_table = {
    'apple': 1,
    'banana': 2,
    'orange': 3
}

# Проверяем наличие ключа и выводим значение
fruit = input('Введите название фрукта: ')
if fruit in hash_table:
    print(f'Количество {fruit}:', hash_table[fruit])
else:
    print('Такой фрукт не найден.')
