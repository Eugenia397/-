ОПРЕДЕЛЕНИЕ ДЕРЕВА
Дерево представляет собой граф без циклов, в котором каждая пара вершин соединяется единственным путем. 
Ключевые характеристики дерева включают выделение одной специальной вершины, называемой корнем, остальные вершины располагаются на уровнях ниже корня. 
Все рёбра ориентированы от корня к листьям (конечным вершинам). 
Каждая вершина имеет ровно одну исходящую связь, кроме корня, у которого отсутствуют входящие связи. 
Деревья широко используются для представления иерархических структур, таких как файловые системы компьютеров, генеалогические древа и организационные схемы.


ОПРЕДЕЛЕНИЕ ГРАФА
Граф — это математическая конструкция, представляющая собой совокупность элементов, называемых вершинами, и связывающих их линий, именуемых рёбрами. 
Графы характеризуются двумя основными свойствами:
  Направленность: Рёбра могут быть либо односторонними (ориентированный граф), либо двунаправленными (неориентированный).
  Весовая нагрузка: Каждый элемент соединения может иметь определённый вес (взвешенный граф) или не иметь никакого веса (невзвешенный).
Примеры графов распространены повсюду: сетевые структуры социальных сетей, топология дорог городов, электрические цепи и многое другое.


РЕАЛИЗАЦИЯ ДЕРЕВЬЕВ И ГРАФОВ на Python, Java и C++
1) ПРИМЕР ДЕРЕВА НА Python
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

def insert(root, node):
    if root is None:
        return node
    else:
        if root.val < node.val:
            if root.right is None:
                root.right = node
            else:
                insert(root.right, node)
        else:
            if root.left is None:
                root.left = node
            else:
                insert(root.left, node)
# Создание дерева
r = Node(50)
insert(r,Node(30))
insert(r,Node(20))
insert(r,Node(40))
insert(r,Node(70))
insert(r,Node(60))
insert(r,Node(80))

Использование и анализ:
Эта реализация позволяет создавать дерево с узлами, вставлять новые узлы и поддерживать структуру дерева согласно правилам BST (бинарного дерева поиска): 
левое поддерево каждого узла содержит значения меньше текущего узла, правое — больше.


2) ПРИМЕР ГРАФА НА Java
import java.util.ArrayList;
import java.util.List;

class GraphVertex {
    int id;
    List<GraphVertex> neighbors;

    public GraphVertex(int id) {
        this.id = id;
        this.neighbors = new ArrayList<>();
    }

    public void addNeighbor(GraphVertex vertex) {
        neighbors.add(vertex);
    }
}

# Использование
GraphVertex A = new GraphVertex(1);
GraphVertex B = new GraphVertex(2);
A.addNeighbor(B);
B.addNeighbor(A);

Анализ:
Представленный фрагмент реализует граф посредством списка смежности.
Здесь каждая вершина сохраняет список своих соседних вершин.
Этот подход обеспечивает удобство добавления новых вершин и обновлений структуры графа, а также эффективен с точки зрения расхода памяти.


3) ПРИМЕР ГРАФА НА C++
#include <iostream>
#include <vector>

using namespace std;

class Vertex {
public:
    int id;
    vector<Vertex*> neighbors;

    Vertex(int id) : id(id) {}

    void addNeighbor(Vertex* neighbor) {
        neighbors.push_back(neighbor);
    }
};

# Использование
int main() {
    Vertex A(1), B(2);
    A.addNeighbor(&B);
    B.addNeighbor(&A);
    return 0;
}

Анализ:
Код иллюстрирует простое представление графа на C++, используя классы и указатели.
Вершины содержат уникальный идентификатор и вектор ссылок на смежные вершины.
Добавление соседей осуществляется путём сохранения указателя на соответствующую вершину.
Такая реализация оптимальна с точки зрения производительности и экономии памяти благодаря использованию указателей.



Обход дерева методом Depth First Search (DFS) на Python
def dfs(node):
    visited = set()
    stack = [node]

    while stack:
        current = stack.pop()
        if current not in visited:
            visited.add(current)
            print(current.value)
            stack.extend(reversed(current.children))

Пошаговый разбор алгоритма:
Алгоритм начинается с начальной вершины (корня дерева). Затем выполняются следующие шаги:
Текущая вершина извлекается из стека.
Если вершина ещё не была обработана ранее (отсутствует в множестве visited), она добавляется в множество посещённых вершин и её значение выводится.
Дети текущей вершины помещаются обратно в стек в обратном порядке, чтобы обеспечить корректный порядок обхода.
Процесс повторяется, пока стек не опустеет.

Оценка временной сложности:
Каждая вершина и каждое ребро проверяются единожды. Таким образом, временная сложность алгоритма DFS равна O(N+E), где N — число вершин, а E — число рёбер.

